```markdown

Коллекция не является потоком данных - если бы была, то элементы обрабатывались бы последовательно в таком коде:

```kotlin
collection
    .filter {...}
    .map {...}
    ...
```

Но коллекция - это просто объет: каждая операция выполняется над всей последовательностью. И в результате все результаты мы получаем одновременно.

Но если вызвать метод asSequence(), то коллекция становиться потоком данных и элементы будут обрабатываться последовательно:

val numbers = listOf(3, 4, 6, 8 , 16, 7, 11).asSequence()

Поток данных нужно запускать в работу, если этого не делать, то никакие промежуточные действия выполняться не будут: ни фильтрация, ни ... Существуют 
1) промежуточные операторы - методы, которые возвращают объект Sequence<T> - выполняет свои дела, и передаёт дальше
2) терминальные операторы - завершающее действие(что нужно сделать в конце обработки потока). Пример: .forEach, ... Это методы не возвращают Sequence<T>.

Причём здесь Flow????
В андроид работать с чистыми потоками проблематично, но есть корутины. Внутри функции main можно запускать корутины, если объявить её suspend - как правило это используется в качестве тестирования.

suspend fun main() { ... }

то же самое, что и 

fun main(): Unit = runBlocking { ... }

Мы создаём корутину, и дожидаемся, пока она не будет выполнена.

val numbers = listOf(3, 4, 6, 8 , 16, 7, 11).asSequence()
numbers.filter { it.isPrime() } // ошибка

Переданная filter лямбда не является саспенд функцией. Работа с потоками данных будет выполняться не в контексте корутины. Т.е. вызывать саспенд функции внутри объекта Sequence нельзя. Они не поддерживают асинхронную обработку данных. Именно по этой причине мы будем использовать Flow. Он как Sequence, но умеет работать асинхронно и во всех его промежуточных операциях мы можем вызывать саспенд функции. Именя этих операций такие же(за редким исключением), но другой тип.
forEach == collect для Flow

Сосздать Flow из коллекции

val numbers = listOf(3, 4, 6, 8 , 16, 7, 11).asFlow()
numbers.filter { it.isPrime() }. collect { println(it) } // всё работает.

Виды Flow builder:
* asFlow()
* flowOf(разные объекты)

val numbers = flowOf(3, 4, 6, 8 , 16, 7, 11)  // или flowOf<Typ>(...)
...

------------------------------------------------------

Обычно эти функции asFlow() и flowOf() используются редко - когда нужно ссимитировать загрузку данных из сети для тестирования, например.
Чаще используют билдер flow:

flow { this: FlowCollector<Int> ->
    val a = 6 
    ...
    this.emit(a)
    delay(1000)
    emit(a * 2)
    println(
}

внутри можно использовать FlowCollector - есть метод emit(value) - кладёт значение в поток. Его можно вызывать сколько угодно раз. Преимущество билдера в том, что мы передаём ему лямбду, в которой мы можем писать любую логику. Особенность: внутри используется корутин контекст, т.е. лямбда является suspend функцией, а значит мы здесь можем вызывать любые другие suspend функции. После вызова emit(), значения прилетают в объект Flow и обрабатываются промежуточными операторами(если был вызван терминальный оператор, например, collect). Но в поток нельзя положить значение снаружи.

Зачем было добавлять Flow, если есть корутины? Их функциональности где-то не хватает? Да - мы с их помощью не можем сделать автоматическое обновление данных - мы используем императивный подход, где нам нужно постоянно запрашивать данные. Все эти проблемы решаются при помощи реактивного подхода и при помощи паттерна Observer(у нас есть какой-то объект, на который мы можем подписаться; и если там происходят изменения, то там автоматически срабатывает уведомление и вызывается какой-то код).
Проблема корутин - они не поддерживают реактивный подход - они поддерживают императивный подход и мы всегда можем возвращать какие-то конкретные объекты(коллекции, строки, ...).

Таким образом, вместо возвращения List<String> можно возвращать Flow<List<String>>:

suspend fun loadUsers(): Flow<List<String>> = flow {
    delay(10)
    emit(users.toList())
}

...
repository.loadUsers()
    .collect {
        делаем какие-то полезные действия
    }

Если нужно постоянно запрашивать обновления из интернета, то можно сделать так(ОЧЕНЬ ПЛОХОЙ ВАРИАНТ):

suspend fun loadUsers(): Flow<List<String>> = flow {
    while (true) {
        delay(10)
        emit(users.toList())
    }
}

--------------------------------------------------

Можно использовать один Flow в нутри другого Flow

fun getFlowByFlowOfBuilder(): Flow<Int> {
    return flowOf(3, 4, 8, 16, 11, 9, 13)
}

fun getFlowByBuilderFlow(): Flow<Int> {
    val firstFlow = getFlowByFlowOfBuilder()
    return flow {
        firstFlow.collect {
            println("Emitted from first flow $it")
            emit(it)
        }
    }
}

Мы можем вызывать suspend функцию collect из не suspend функции getFlowByBuilderFlow, потому что лямбда, которая передаётся flow является suspend функцией. Но в каком скоупе будет эта функция выполняться? Потоки данных не выполняются до тех пор, пока мы не вызовем терминальный оператор. Поэтому вызывать функцию getFlowByBuilderFlow и создавать объект Flow мы можем из любого места программы - корутины нам для этого не нужны. А все терминальные операторы являются suspend функциями, поэтому именно при помощи них мы можем запускать Flow - операторы предоставляют контекст. Поэтому мы и main сделали suspend. Т.е. Flow будет выполняться в том контексте, в котором вызван терминальный оператор.

Другой метод для билдера - emitFlow(поток) - он берём все данные из потока и emit'ит их в свой Flow:

fun getFlowByBuilderFlow(): Flow<Int> {
    val firstFlow = getFlowByFlowOfBuilder()
    return flow {
        emitAll(firstFlow)
    }
}

Терминальные операторы:
* .toList() - suspend функция(зывывать можно только из корутины - преобразовать поток в коллекцию. Она будет создана, когда данные в потоке закончатся
*  .first() - вернуть первый элемент из потока и завершить поток(дальнейшие emit производиться не будут)
*  .last() - вернуть последний элемент из потока и завершить поток(дальнейшие emit производиться не будут)

-----------------------------------------------

Промежуточные операторы, которые никак не влияют на данные, а просто реагируют на определённые действия:
* onStart { ... } - реакция на прилёт(emit) первых данных в Flow. С помощью этого можно, например, встроить установку стейта.
* onEach { ... } - реагируем на каждый следующий emit. По сути, весь код из collect можно перенести в onEach {}

Мы можем вызывать функцию так:

viewModelScope.launch {
    repository.getCurrencyList()
        .onStart { }
        . ...
        .collect()
} 

а можно это делать с помощью оператора .launchIn(scope):

repository.getCurrencyList()
    .onStart { }
    . ...
    .launchIn(viewModelScope)

launchIn - терминальный оператор, но он не является suspend функцией - это исключение. Под капотом он работает так:

public fun <T> Flow<T>.launchIn(scope: CoroutineScope): Job = scope.launch {
    collect()
}

Т.е. делает то же, что и выше. 

-------------------------------------------

onStart, как и flow() принимает FlowCollector<T>, а значит внутри onStart мы можем использовать emit(Value) и эмитить значение в поток данных:

...
.onStart { emit(State.Loading) }
...

Что такое объект LiveData и чем он отличается от объекта Flow? Объект LiveData содержит стейт, на который можно подписаться и он будет обновляться, например, на экране в режиме реального времени. При этом, Flow также содержит объект Стейт, на который можно подписаться и реагировать на изменения в нём.
Чтобы преобразовать Flow в LiveData можно воспользоваться терминальным оператором asLiveData():

...
.asLiveData()

Теперь, когда мы преобразовали этот объект в LiveData, то мы можем на него подписываться в Activity/Fragment и реагировать на изменение стейта, отображая его на экране.




-------------------------------------------

-------------------------------------------

-------------------------------------------

Что если мы вызовем collect два раза на одном и том же объекте?

suspend fun main() {
    val flow = getFlow()
    flow.collect {
        println(it)
    }
     flow.collect {
        println(it)
    }
}

fun getFlow(): Flow<Int> = flow {
    repeat(100) {
        println("Emitted: $it")
        emit(it)
        delay(1000)
    }
}

Вторая collect не будет выполняться, пока не будут выведены первые сто чисел - она является suspend функцией - она приостанавлявает корутину до тех пор, пока все данные из потока не будут обработаны. Чтобы они выполнялись одновременно, можно запустить их в отдельных корутин скоуп:

suspend fun main() {
    val flow = getFlow()
    coroutineScope.launch {
        flow.collect {
            println(it)
        }
    }

    coroutineScope.launch {
        flow.collect {
            println(it)
        }
    }
    
}

Программа будет завершаться практически мгновенно - потоки даже не успевают заэмиттить какое-либо значение(ну или одно или пару, если успели). Это происходит из-за особенности реализации корутин - когда главный поток(в данном случае main) был запущен, он создал две корутины, а после - main функция завершается(главный поток). А когда главный поток завершается, все корутины отменяются. Это происходит из-за того, что под потоком все диспатчеры используют потоки демоны - они прекращают свою работу, когда прекращают свою работу все основные потоки приложения.

Чтобы это исправить, можно сохранить Job обекты и сделать так:

suspend fun main() {
    val flow = getFlow()
    val job1 = coroutineScope.launch {
        flow.collect {
            println(it)
        }
    }

    val job2 = coroutineScope.launch {
        flow.collect {
            println(it)
        }
    }
    job1.join()
    job2.join()
    
}

join() приостанавливает поток, пока job1 корутина не будет завершена.

Здесь мы создавали Холодные потоки. У холодных Observable объектов или у холодных потоков есть особенности:
* они не будут эмитить данные, пока на них никто не подпишится - пока не будет вызван терминальный оператор.
* на каждую подписку - на каждый терминальный оператор создаётся свой Flow

suspend fun main() {
    val flow = getFlow()
    val job1 = coroutineScope.launch {
        flow.collect {
            println(it)
        }
    }
    delay(5000)
    val job2 = coroutineScope.launch {
        flow.collect {
            println(it)
        }
    }
    job1.join()
    job2.join()

}

когда мы в первой корутине досчитаем до 5 или 4х, у нас создаётся вторая корутина и начинае счёт с нуля - т.е. потоки не завися друг от друга.

* Если какому-то коллектору данные больше не нужны и он перестаёт их принимать, то и поток прекратит своё выполнение:

suspend fun main() {
    val flow = getFlow()
    val job1 = coroutineScope.launch {
        flow.first().let {
            println(it)
        }
    }
    delay(5000)
    val job2 = coroutineScope.launch {
        flow.collect {
            println(it)
        }
    }
    job1.join()
    job2.join()

}

Мы в первом потоке досчитаем до 0 и всё, а уже потом начнёт работать второй поток.

-------------------------------------------

Горячие потоки - полная противоположность холодных потоков.

 















Коллекция не является потоком данных - если бы была, то элементы обрабатывались бы последовательно в таком коде:

collection
    .filter {...}
    .map {...}
    ...

Но коллекция - это просто объет: каждая операция выполняется над всей последовательностью. И в результате все результаты мы получаем одновременно.

Но если вызвать метод asSequence(), то коллекция становиться потоком данных и элементы будут обрабатываться последовательно:

val numbers = listOf(3, 4, 6, 8 , 16, 7, 11).asSequence()

Поток данных нужно запускать в работу, если этого не делать, то никакие промежуточные действия выполняться не будут: ни фильтрация, ни ... Существуют 
1) промежуточные операторы - методы, которые возвращают объект Sequence<T> - выполняет свои дела, и передаёт дальше
2) терминальные операторы - завершающее действие(что нужно сделать в конце обработки потока). Пример: .forEach, ... Это методы не возвращают Sequence<T>.

Причём здесь Flow????
В андроид работать с чистыми потоками проблематично, но есть корутины. Внутри функции main можно запускать корутины, если объявить её suspend - как правило это используется в качестве тестирования.

suspend fun main() { ... }

то же самое, что и 

fun main(): Unit = runBlocking { ... }

Мы создаём корутину, и дожидаемся, пока она не будет выполнена.

val numbers = listOf(3, 4, 6, 8 , 16, 7, 11).asSequence()
numbers.filter { it.isPrime() } // ошибка

Переданная filter лямбда не является саспенд функцией. Работа с потоками данных будет выполняться не в контексте корутины. Т.е. вызывать саспенд функции внутри объекта Sequence нельзя. Они не поддерживают асинхронную обработку данных. Именно по этой причине мы будем использовать Flow. Он как Sequence, но умеет работать асинхронно и во всех его промежуточных операциях мы можем вызывать саспенд функции. Именя этих операций такие же(за редким исключением), но другой тип.
forEach == collect для Flow

Сосздать Flow из коллекции

val numbers = listOf(3, 4, 6, 8 , 16, 7, 11).asFlow()
numbers.filter { it.isPrime() }. collect { println(it) } // всё работает.

Виды Flow builder:
* asFlow()
* flowOf(разные объекты)

import kotlinx.coroutines.*

suspend fun Int.isPrime(): Boolean {
    if (this <= 1) return false
        for (i in 2 .. this / 2) {
            delay(500)
            if (this % i == 0) return false
            }
    return true
}

suspend fun main() {
    val numbers = listOf(3, 8 , 16, 7, 11)
                  //.asSequence()
                  numbers
                  .filter { it.isPrime() }
                  .filter { it > 5 }
    .map {
        println("Map")
        "Number: $it"
    }
    //.forEach { println(it) }
    println("end")
}

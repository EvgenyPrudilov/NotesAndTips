```markdown
_Что есть полиморфизм?_ (из - Introduction to Programming Lanugages)

Полиморфизм - это одна из стратегий переиспользования кода(фрагментов/модулей/функций/...). Мы можем с помощью одного имени выразить разные сущности. Классификация:
Полиморфизм
|___ad-hoc (Ad-hoc полиморфизм)
|   |___coercion (приведения типов?)
|   |___overloading (перегрузки)
|___universal (универсальный полиморфизм)
    |___parametric (параметрический)
    |___subtyping (подтипов)

Ad-hoc полиморфизм - одно имя может выражать конечное множество сущностей.
универсальный полиморфизм - одно имя может выражать практически бесконечное количество сущностей/типов.

_Перегрузка_

Одно имя может выражать конечное множество операций, которое может быть как оператором, так и функцией/методом. Самый известный пример - перегрузка оператора(operator overloading): во многих языках мы можем использовать оператор + как для сложения целых чисел, так и сложения чисел с плавающей точкой, хотя принципы сложения у них совершенно разные.

Некоторые языки предоставляют лишь встроенные перегруженные операторы(типа С), но  большенство сейчас таки предоставляет возможность перегрузки программисту. 

```c
#include <iostream>
int sum(int a, int b) { return a + b; }
double sum(double a, double b) { return a + b; }

int main() {
    std::cout << "Sum = " << sum(1, 1) << std::endl; 
    std::cout << "Sum = " << sum(1.2, 1.2) << std::endl;  
}
```

Нужная реализация будет выбрана при компиляции, основываясь на сигнатуре(signature) функции/метода, которая состоит из имени и типов принимаемых параметров(причём порядок типов важен). В большинстве языков сигнатура не содержит тип возвращаемого значения - значит, что сигратура является контекстно нечувствительной(context insensitive). Выбор нужной реализации на основе имени и параметров называется разрешение перезагрузки(overload resolution).

Реализовать перегрузку просто - компилятор просто генерирует разные имена для разных реализаций:

```
$> g++ -S sum.cpp
$> cat over.s
...
.globl __Z3sumdd
__Z3sumdd:
...
.globl __Z3sumii
__Z3sumii:
...
```

_Приведения типов_

Многие языки явные или неявные приведения типов к другим типам. Явное приведение осуществляется самим программистом:

double x, y;
x = 3;              // неявное приведение (implicit coercion)
y = (double) 5;     // явное приведение (explicit coercion) ==> casting

Чтобы различать явное и неявное приведение у явного есть спец термин - casting - мы кастуем один тип к другому. 
С помощью приведения языки дают возможность легко и приятно комбинировать значения разных типов. Но для неявного приведения язык должен обладать правилами приведения одного типа к другому, которые будут автоматически применяться, если, конечно, это совместимые типы. Эти правила являются частью семантики языка.

Неявное приведение может приводить к трудностям в понимании кода. Ситуация обостряется, когда приведение используется совместно с перегрузкой:

#include <iostream>
int square(int a) {
    std::cout << "Square of ints\n";
    return a * a;
}
double square(double a) {
    std::cout << "Square of doubles\n";
    return a * a;
}
int main() {
    double b = 'a';
    int i = 'a';

    std::cout << square(b) << std::endl;    // что здесь?
    std::cout << square(i) << std::endl;    // что здесь?
    std::cout << square('a') << std::endl;  // а здесь??
}

Правила приведения(часть семантиги языка) дает целые числа вместо двойных при преобразовании символов.
Ладно, а что будет здесь:

#include <iostream>
int sum(int a, int b) { return a + b; }
double sum(double a, double b) { return a + b; }

int main() {
    std::cout << "Sum = " << sum(1, 2.1) << std::endl;  // ??
}

Это даже компилироваться не будет

_Параметрический полиморфизм_

Имена могут быть параметризированны более чем одним типом. Этот тип полиморфизма позволяет нам писать обобщённый код - он может работать с разными типами. 
Например, в С++ примером этого полиморфизма будут шаблоны:

#include <iostream>

template <class T>
T GetMax(T a, T b) {
    T result;
    result = (a > b) ? a : b;
    return (result);
}

int main() {
    int i = 5, j = 6, k;
    long l = 10, m = 5, j;
    k = GetMax<int>(i, j);   // типовой параметр - int
    n = GetMax<long>(l, m);  // типовой параметр - long
}

Таким образом, тип T заменяется на реальный тип. Причём важно, чтобы тип T поддерживал все те операции, в которых он учавствует(в данном случае - сравнение).
Обобщённые типы присутствуют во многих языках, но реализованы они могут по разному. Например, в С++ каждый экземпляр обобщённой функции компилируется по разному для каждого типа. В Java компилятор создаёт лишь один экземпляр для всех функции.

Размышляя об параметрическом полиморфизме, мы придём к идее конструктора типа(type constructor). Это такая фукнция, которая принимает типы и производит новый тип. Мы не можем получить объект типа List<T>, но мы может передать сюда тип и получить новый тип List<Integer>, и уже с помощью него можно создать объект.

Не все языки обладают параметрическим полиморфизмом, но иногда можно его имитировать. Например, в Си мы можем воспользоваться макросами:

#include <stdio.h>
#define SWAP(T, X, Y) {T __aux = X; X= Y; Y = __aux;}

int main() {
    int i0 = 0, i1 = 1;
    char *c0 = "Hello", *c1 = "World!";
    SWAP(int, i0, i1);
    SWAP(char*, c0, c1);
    printf("%d, %d\n", i0, i1);
    printf("%s, %s\n", c0, c1);
}

_Полиморфизм подтипов(подтипизация)_

Хорошо известен в ООП языках принцип подстановки барбары лисков(Liskov's Substitution Principle). Он говорит, что пока слева от присваивания ожидается тип T, допустимо получить тип S, если тип S является подтипом(subtype) типа T. Если язык следует этому принципу, то он поддерживат полиморфизм подтипов.
В примере все три типа String, Integer и LinkedList<Integer> являются подтипами Object:

import java.util.LinkedList;
public  class Sub {
    public static void print(Object o) {
        System.out.println(o);
    }
    public static void main(String[] a) {
        print(new String("dcc024"));
        print(new Integer(42));
        print(new LinkedList<Integer>());
    }
}

Этот тип полиморфизма работает, потому что тип S (являясь подтипом T) соблюдает контракт, ожидаемый от T, т.е. все поля/методы из типа T есть и в S. Обычно, в подтипе содержиться больше свойств, чем в родителе.

Есть два основных механизма для отношения подтипов(subtype relation). Наиболее часто используется номинальная подтипизация(nominal subtyping). Суть в том, что программист должен явно указать, что тип S является подтипом типа T. В Java, например, используем ключевое слово extends:

class Animal {
    public void eat() {
        System.out.println(this + " is eating");
    }
    public String toString() {
        return "Animal";
    }
} 
class Mammal extends Animal {
    public void suckMilk() {
        System.out.println(this + "is sucking");
    }
    public void eat() {
        suckMilk();
    }
}

Другой механизм - структурная подтипизация(structural subtyping). Используется в Ocaml.
!!! Пока не разобрался !!!

```
